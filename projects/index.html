---
title: Projects
permalink: /projects/
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Projects — Claire Shin</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet" />
  <style>
    @font-face {
      font-family: 'Craftwork Grotesk';
      src: url('https://font.download/cdn/webfont/craftwork-grotesk/CraftworkGrotesk-Regular.woff') format('woff');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0e;
      --text: #e8e6e1;
      --text-mid: rgba(255,255,255,0.4);
      --text-dim: rgba(255,255,255,0.25);
      --card-bg: rgba(255,255,255,0.02);
      --card-border: rgba(255,255,255,0.06);
      --card-desc: rgba(255,255,255,0.45);
      --tech-bg: rgba(255,255,255,0.04);
      --tech-border: rgba(255,255,255,0.08);
      --tech-text: rgba(255,255,255,0.4);
      --arrow: rgba(255,255,255,0.15);
      --shadow-hover: rgba(0,0,0,0.4);
      --sigil-opacity: 0.35;
      --sigil-hover-opacity: 0.55;
      --canvas-fade: rgba(10,10,14,0.06);
    }
    :root.light {
      --bg: #eef2f7;
      --text: #4a4a4e;
      --text-mid: rgba(0,0,0,0.45);
      --text-dim: rgba(0,0,0,0.3);
      --card-bg: rgba(0,0,0,0.03);
      --card-border: rgba(0,0,0,0.08);
      --card-desc: rgba(0,0,0,0.5);
      --tech-bg: rgba(0,0,0,0.04);
      --tech-border: rgba(0,0,0,0.1);
      --tech-text: rgba(0,0,0,0.45);
      --arrow: rgba(0,0,0,0.2);
      --shadow-hover: rgba(0,0,0,0.1);
      --sigil-opacity: 0.2;
      --sigil-hover-opacity: 0.35;
      --canvas-fade: rgba(238,242,247,0.06);
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'IBM Plex Sans', system-ui, sans-serif;
      overflow-x: hidden;
      min-height: 100vh;
      transition: background 0.4s ease, color 0.4s ease;
    }

    /* ── NAV ── */
    .nav {
      padding: 24px 32px;
      border-bottom: 1px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: border-color 0.4s ease;
    }
    .nav-links { display: flex; align-items: center; gap: 20px; }
    .nav a {
      color: var(--text-mid);
      text-decoration: none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      letter-spacing: 2px;
      text-transform: uppercase;
      transition: color 0.3s;
    }
    .nav a:hover { color: var(--text); }

    /* ── THEME TOGGLE ── */
    .theme-toggle {
      background: none;
      border: 1px solid var(--card-border);
      border-radius: 20px;
      padding: 6px 12px;
      cursor: pointer;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      color: var(--text-mid);
      transition: color 0.3s, border-color 0.3s, background 0.3s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .theme-toggle:hover {
      color: var(--text);
      border-color: var(--text-mid);
      background: var(--card-bg);
    }
    .theme-toggle .icon { font-size: 13px; }

    /* ── HEADER ── */
    .header {
      padding: 48px 32px 40px;
      max-width: 900px;
      margin: 0 auto;
    }
    .header-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      letter-spacing: 4px;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-bottom: 12px;
    }
    .header h1 {
      font-family: 'Craftwork Grotesk', 'Helvetica Neue', Helvetica, sans-serif;
      font-size: clamp(28px, 5vw, 42px);
      font-weight: 400;
      letter-spacing: -0.5px;
      line-height: 1.2;
      margin-bottom: 12px;
    }
    .header p {
      font-size: 16px;
      line-height: 1.7;
      color: var(--text-mid);
      font-weight: 300;
      max-width: 520px;
    }

    /* ── GRID ── */
    .grid {
      max-width: 900px;
      margin: 0 auto;
      padding: 0 32px 80px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-auto-rows: minmax(260px, auto);
      gap: 20px;
    }

    /* ── CARD ── */
    .card {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      cursor: pointer;
      text-decoration: none;
      color: inherit;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 28px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1),
                  box-shadow 0.5s cubic-bezier(0.16, 1, 0.3, 1),
                  border-color 0.4s ease,
                  background 0.4s ease;
      /* entry animation */
      opacity: 0;
      transform: translateY(28px);
    }
    .card.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .card.hero {
      grid-column: span 2;
      min-height: 320px;
    }
    .card:hover {
      transform: translateY(-4px) scale(1.01);
      box-shadow: 0 20px 60px var(--shadow-hover);
    }

    /* spotlight glow */
    .card::before {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(
        400px circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
        var(--glow-color, rgba(123,104,238,0.08)),
        transparent 60%
      );
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: 1;
    }
    .card:hover::before { opacity: 1; }

    /* border glow on hover */
    .card:hover {
      border-color: var(--accent-dim, rgba(123,104,238,0.2));
    }

    /* canvas sigil */
    .card canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 0;
      opacity: var(--sigil-opacity);
      transition: opacity 0.4s ease;
    }
    .card:hover canvas { opacity: var(--sigil-hover-opacity); }

    /* card content */
    .card-content {
      position: relative;
      z-index: 2;
    }
    .card-tag {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 10px;
      opacity: 0.5;
    }
    .card-title {
      font-family: 'Craftwork Grotesk', 'Helvetica Neue', Helvetica, sans-serif;
      font-size: clamp(20px, 2.5vw, 28px);
      font-weight: 400;
      letter-spacing: -0.3px;
      margin-bottom: 8px;
      line-height: 1.25;
      transition: color 0.3s ease;
    }
    .card:hover .card-title { color: var(--accent, #7b68ee); }
    .card-desc {
      font-size: 15px;
      line-height: 1.65;
      color: var(--card-desc);
      font-weight: 300;
      max-width: 480px;
    }
    .card-tech {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 14px;
    }
    .card-tech span {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      letter-spacing: 1px;
      padding: 4px 10px;
      border-radius: 20px;
      background: var(--tech-bg);
      border: 1px solid var(--tech-border);
      color: var(--tech-text);
    }
    .card-arrow {
      position: absolute;
      top: 24px;
      right: 24px;
      z-index: 2;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 18px;
      color: var(--arrow);
      transition: color 0.3s, transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    .card:hover .card-arrow {
      color: var(--accent, #7b68ee);
      transform: translate(3px, -3px);
    }

    /* ── PHILOSOPHY LINK ── */
    .philosophy-link {
      max-width: 900px;
      margin: 0 auto 60px;
      padding: 0 32px;
    }
    .philosophy-link a {
      display: block;
      position: relative;
      border-radius: 14px;
      padding: 32px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      text-decoration: none;
      color: inherit;
      transition: border-color 0.3s, box-shadow 0.3s, background 0.4s ease, transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      /* entry animation */
      opacity: 0;
      transform: translateY(28px);
    }
    .philosophy-link a.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .philosophy-link a:hover {
      border-color: rgba(123,104,238,0.2);
      box-shadow: 0 12px 40px var(--shadow-hover);
      transform: translateY(-3px);
    }
    .philosophy-link .pl-tag {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-bottom: 8px;
    }
    .philosophy-link .pl-title {
      font-family: 'Craftwork Grotesk', 'Helvetica Neue', Helvetica, sans-serif;
      font-size: clamp(20px, 2.5vw, 26px);
      font-weight: 400;
      letter-spacing: -0.3px;
      margin-bottom: 6px;
      transition: color 0.3s;
    }
    .philosophy-link a:hover .pl-title { color: #7b68ee; }
    .philosophy-link .pl-desc {
      font-size: 15px;
      color: var(--text-mid);
      font-weight: 300;
    }

    /* ── PARTICLE BG ── */
    #particle-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    .nav, .header, .grid, .philosophy-link { position: relative; z-index: 1; }

    /* ── RESPONSIVE ── */
    @media (max-width: 640px) {
      .grid { grid-template-columns: 1fr; }
      .card.hero { grid-column: span 1; }
      .header, .grid, .philosophy-link { padding-left: 20px; padding-right: 20px; }
    }
  </style>
</head>
<body>
  <canvas id="particle-bg"></canvas>
  <nav class="nav">
    <a href="/">← Home</a>
    <div class="nav-links">
      <a href="/about/">About</a>
      <button class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark mode">
        <span class="icon" id="theme-icon">☀</span>
        <span id="theme-label">Light</span>
      </button>
    </div>
  </nav>

  <div class="header">
    <div class="header-label">What I'm building</div>
    <h1>Projects</h1>
    <p>Tools for thinking about markets.</p>
  </div>

  <div class="grid" id="project-grid">

    <!-- HERO: Volatility Archaeologist -->
    <a class="card hero"
       href="https://github.com/claireshinc/volsurface-dislocation"
       target="_blank" rel="noopener"
       style="--accent: #7b68ee; --accent-dim: rgba(123,104,238,0.2); --glow-color: rgba(123,104,238,0.08);"
       data-delay="0">
      <canvas data-sigil="volsurface"></canvas>
      <span class="card-arrow">&#8599;</span>
      <div class="card-content">
        <div class="card-tag" style="color: #7b68ee;">Options & Derivatives</div>
        <div class="card-title">Volatility Archaeologist</div>
        <div class="card-desc">
          SVI surface fitting, feature extraction, and anomaly detection for options markets. Finds mispricings by comparing current surface geometry to historical distributions — then generates trade ideas.
        </div>
        <div class="card-tech">
          <span>Python</span>
          <span>SVI Model</span>
          <span>Streamlit</span>
          <span>FastAPI</span>
          <span>Anomaly Detection</span>
        </div>
      </div>
    </a>

    <!-- Sector Momentum -->
    <a class="card"
       href="https://github.com/claireshinc/sector-momentum"
       target="_blank" rel="noopener"
       style="--accent: #ef476f; --accent-dim: rgba(239,71,111,0.2); --glow-color: rgba(239,71,111,0.08);"
       data-delay="100">
      <canvas data-sigil="momentum"></canvas>
      <span class="card-arrow">&#8599;</span>
      <div class="card-content">
        <div class="card-tag" style="color: #ef476f;">Systematic Equities</div>
        <div class="card-title">Sector Momentum</div>
        <div class="card-desc">
          Crash-aware long/short sector momentum with sentiment gating. Runs three crash controllers as counterfactuals against the same baseline.
        </div>
        <div class="card-tech">
          <span>Python</span>
          <span>Backtesting</span>
          <span>Sector ETFs</span>
        </div>
      </div>
    </a>

    <!-- Thesis OS -->
    <a class="card"
       href="https://github.com/claireshinc/thesis-os"
       target="_blank" rel="noopener"
       style="--accent: #06d6a0; --accent-dim: rgba(6,214,160,0.2); --glow-color: rgba(6,214,160,0.08);"
       data-delay="200">
      <canvas data-sigil="thesis"></canvas>
      <span class="card-arrow">&#8599;</span>
      <div class="card-content">
        <div class="card-tag" style="color: #06d6a0;">Fundamental Equity PM</div>
        <div class="card-title">Thesis OS</div>
        <div class="card-desc">
          Structured briefs and investment theses compiled into testable claims with kill criteria. Decision artifacts for fundamental equity PMs.
        </div>
        <div class="card-tech">
          <span>Python</span>
          <span>Node.js</span>
          <span>Postgres</span>
          <span>uv</span>
        </div>
      </div>
    </a>

  </div>

  <!-- Philosophy project link -->
  <div class="philosophy-link">
    <a href="/projects/philosophy/" data-delay="300">
      <div class="pl-tag">Interactive Essay</div>
      <div class="pl-title">Philosophy as Mathematics</div>
      <div class="pl-desc">
        Five philosophical ideas rendered as live mathematical simulations — Heraclitus, Plato, Hegel, Nietzsche, and Kocherlakota.
      </div>
    </a>
  </div>

  <script>
    // ═══════════════ THEME TOGGLE ═══════════════
    const toggle = document.getElementById('theme-toggle');
    const icon = document.getElementById('theme-icon');
    const label = document.getElementById('theme-label');
    const root = document.documentElement;

    function setTheme(mode) {
      if (mode === 'light') {
        root.classList.add('light');
        icon.textContent = '☾';
        label.textContent = 'Dark';
      } else {
        root.classList.remove('light');
        icon.textContent = '☀';
        label.textContent = 'Light';
      }
      localStorage.setItem('theme', mode);
      // redraw sigils with new colors
      setTimeout(initSigils, 50);
    }

    toggle.addEventListener('click', () => {
      setTheme(root.classList.contains('light') ? 'dark' : 'light');
    });

    // restore saved preference
    const saved = localStorage.getItem('theme');
    if (saved) setTheme(saved);

    // ═══════════════ SPOTLIGHT GLOW ═══════════════
    document.querySelectorAll('.card').forEach(card => {
      card.addEventListener('mousemove', e => {
        const rect = card.getBoundingClientRect();
        card.style.setProperty('--mouse-x', (e.clientX - rect.left) + 'px');
        card.style.setProperty('--mouse-y', (e.clientY - rect.top) + 'px');
      });
    });

    // ═══════════════ SCROLL REVEAL ═══════════════
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const delay = parseInt(entry.target.dataset.delay || 0);
          setTimeout(() => {
            entry.target.classList.add('visible');
          }, delay);
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });

    document.querySelectorAll('.card, .philosophy-link a').forEach(el => {
      el.style.transition = `opacity 0.7s cubic-bezier(0.16, 1, 0.3, 1) 0s,
                             transform 0.7s cubic-bezier(0.16, 1, 0.3, 1) 0s,
                             box-shadow 0.5s cubic-bezier(0.16, 1, 0.3, 1),
                             border-color 0.4s ease`;
      observer.observe(el);
    });

    // ═══════════════ GENERATIVE SIGILS ═══════════════
    function initSigils() {
      document.querySelectorAll('canvas[data-sigil]').forEach(canvas => {
        const type = canvas.dataset.sigil;
        const rect = canvas.parentElement.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;

        if (type === 'volsurface') drawVolSurface(ctx, w, h);
        else if (type === 'momentum') drawMomentum(ctx, w, h);
        else if (type === 'thesis') drawThesis(ctx, w, h);
      });
    }

    function isLight() { return document.documentElement.classList.contains('light'); }

    // Vol surface: a stylized volatility smile mesh
    function drawVolSurface(ctx, w, h) {
      const rows = 12, cols = 24;
      ctx.strokeStyle = isLight() ? 'rgba(123,104,238,0.18)' : 'rgba(123,104,238,0.12)';
      ctx.lineWidth = 0.8;
      for (let r = 0; r < rows; r++) {
        ctx.beginPath();
        const yBase = h * 0.25 + (r / rows) * h * 0.55;
        for (let c = 0; c <= cols; c++) {
          const x = (c / cols) * w;
          const t = (c / cols - 0.5) * 2;
          const smile = t * t * 40 + Math.sin(r * 0.5 + t * 3) * 8;
          const depth = 1 - r / rows * 0.3;
          const y = yBase - smile * depth;
          c === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      // vertical wisps
      for (let c = 0; c < cols; c += 3) {
        ctx.beginPath();
        ctx.strokeStyle = isLight() ? 'rgba(123,104,238,0.08)' : 'rgba(184,169,255,0.04)';
        for (let r = 0; r < rows; r++) {
          const x = (c / cols) * w;
          const yBase = h * 0.25 + (r / rows) * h * 0.55;
          const t = (c / cols - 0.5) * 2;
          const smile = t * t * 40 + Math.sin(r * 0.5 + t * 3) * 8;
          const depth = 1 - r / rows * 0.3;
          const y = yBase - smile * depth;
          r === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
    }

    // Momentum: oscillating sine waves with phase shifts
    function drawMomentum(ctx, w, h) {
      const waves = 5;
      for (let i = 0; i < waves; i++) {
        ctx.beginPath();
        const base = isLight() ? 0.1 : 0.06;
        const alpha = base + i * 0.02;
        ctx.strokeStyle = `rgba(239,71,111,${alpha})`;
        ctx.lineWidth = 1 + i * 0.3;
        const freq = 2 + i * 0.7;
        const amp = h * (0.08 + i * 0.04);
        const phase = i * 1.2;
        const yOff = h * 0.5 + (i - waves / 2) * 12;
        for (let x = 0; x <= w; x += 2) {
          const t = x / w;
          const y = yOff + Math.sin(t * Math.PI * freq + phase) * amp * (0.3 + 0.7 * Math.sin(t * Math.PI));
          x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
    }

    // Thesis: branching decision tree / constellation
    function drawThesis(ctx, w, h) {
      const nodes = [];
      const rng = mulberry32(42);
      function addBranch(x, y, depth, angle) {
        if (depth > 4) return;
        nodes.push({ x, y, depth });
        const branches = depth < 2 ? 3 : 2;
        for (let i = 0; i < branches; i++) {
          const a = angle + (i - (branches - 1) / 2) * (0.8 - depth * 0.1);
          const len = (50 - depth * 8) * (0.7 + rng() * 0.6);
          const nx = x + Math.cos(a) * len;
          const ny = y + Math.sin(a) * len;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nx, ny);
          const tBase = isLight() ? 0.14 : 0.08;
          ctx.strokeStyle = `rgba(6,214,160,${tBase - depth * 0.012})`;
          ctx.lineWidth = 2 - depth * 0.35;
          ctx.stroke();
          addBranch(nx, ny, depth + 1, a);
        }
      }
      addBranch(w * 0.15, h * 0.5, 0, -0.3);
      addBranch(w * 0.75, h * 0.35, 0, 0.5);
      nodes.forEach(n => {
        const r = 2.5 - n.depth * 0.4;
        ctx.beginPath();
        ctx.arc(n.x, n.y, Math.max(r, 0.8), 0, Math.PI * 2);
        const nBase = isLight() ? 0.2 : 0.12;
        ctx.fillStyle = `rgba(6,214,160,${nBase - n.depth * 0.02})`;
        ctx.fill();
      });
    }

    // deterministic RNG for reproducible sigils
    function mulberry32(a) {
      return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        var t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // init on load and resize
    window.addEventListener('load', initSigils);
    window.addEventListener('resize', () => { clearTimeout(window._sigilTimer); window._sigilTimer = setTimeout(initSigils, 200); });

    // ═══════════════ PARTICLE TORUS ═══════════════
    (function() {
      const canvas = document.getElementById('particle-bg');
      const ctx = canvas.getContext('2d');
      let w, h, dpr;
      const NUM = 1200;
      const points = [];
      let angle = 0;

      const R = 1.0; // major radius
      const r = 0.38; // minor radius

      for (let i = 0; i < NUM; i++) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        points.push({ u, v });
      }

      function resize() {
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      resize();
      window.addEventListener('resize', resize);

      function draw() {
        const light = document.documentElement.classList.contains('light');
        ctx.clearRect(0, 0, w, h);
        angle += 0.003;

        const scale = Math.min(w, h) * 0.22;
        const cx = w * 0.15, cy = h * 0.45;
        const cosA = Math.cos(angle), sinA = Math.sin(angle);
        const tiltX = 0.4, cosT = Math.cos(tiltX), sinT = Math.sin(tiltX);
        const projected = [];

        for (let i = 0; i < NUM; i++) {
          const p = points[i];
          // torus parametric
          let x = (R + r * Math.cos(p.v)) * Math.cos(p.u);
          let y = (R + r * Math.cos(p.v)) * Math.sin(p.u);
          let z = r * Math.sin(p.v);
          // rotate around Y
          let x1 = x * cosA - z * sinA;
          let z1 = x * sinA + z * cosA;
          // tilt around X
          let y1 = y * cosT - z1 * sinT;
          let z2 = y * sinT + z1 * cosT;

          const depth = (z2 + R + r) / (2 * (R + r));
          projected.push({ sx: cx + x1 * scale, sy: cy + y1 * scale, depth, z: z2 });
        }

        projected.sort((a, b) => a.z - b.z);

        for (const p of projected) {
          const alpha = 0.06 + p.depth * 0.3;
          const sz = 0.6 + p.depth * 1.6;
          if (light) {
            ctx.fillStyle = `rgba(100,50,160,${alpha * 0.45})`;
          } else {
            ctx.fillStyle = `rgba(123,104,238,${alpha})`;
          }
          ctx.beginPath();
          ctx.arc(p.sx, p.sy, sz, 0, Math.PI * 2);
          ctx.fill();
        }

        requestAnimationFrame(draw);
      }
      draw();
    })();
  </script>
</body>
</html>
